"use strict";
var structureImpl = require("./structure/structureImpl");
var structureDefault = require("./structure/structureDefault");
var structureDefaultInterfaces = require("./structure/structureDefaultInterfaces");
var detailsImplementation = require("./node_details/detailsImpl");
var tools = require("./common/tools");
/**
 * Types of node recognizable by default decorator.
 */
exports.NodeType = structureDefaultInterfaces.NodeType;
/**
 * Initializes default contributors.
 */
function initialize() {
    structureDefault.initialize();
}
exports.initialize = initialize;
/**
 * Sets AST provider. Must be called to use the module.
 */
function setASTProvider(astProvider) {
    tools.setASTProvider(astProvider);
}
exports.setASTProvider = setASTProvider;
/**
 * Adds label provider. The system can contain several label providers at once,
 * the first one returning a label will be used.
 * @param provider
 */
function addLabelProvider(provider) {
    structureImpl.addLabelProvider(provider);
}
exports.addLabelProvider = addLabelProvider;
/**
 * Adds decorator. The system can contain severla decorators. The first one providing
 * data will be used.
 * @param decorator
 */
function addDecorator(decorator) {
    structureImpl.addDecorator(decorator);
}
exports.addDecorator = addDecorator;
/**
 * Adds new category and its filter. Each category creates its own structure tree.
 * Several categories may contain the same node.
 * Adding the same category the second tie overrides the filter.
 * @param categoryFilter
 */
function addCategoryFilter(categoryName, categoryFilter) {
    structureImpl.addCategoryFilter(categoryName, categoryFilter);
}
exports.addCategoryFilter = addCategoryFilter;
/**
 * Sets global visibility filters. Nodes being rejected by the filter are not
 * going into the structure tree of any category.
 * @param visibilityFilter
 */
function setVisibilityFilter(visibilityFilter) {
    structureImpl.setVisibilityFilter(visibilityFilter);
}
exports.setVisibilityFilter = setVisibilityFilter;
/**
 * Sets content provider. It is recommended to use the default one.
 * @param contentProvider
 */
function setContentProvider(contentProvider) {
    structureImpl.setContentProvider(contentProvider);
}
exports.setContentProvider = setContentProvider;
/**
 * Sets key provider. It is recommended to use the default one.
 * @param keyProvider
 */
function setKeyProvider(keyProvider) {
    structureImpl.setKeyProvider(keyProvider);
}
exports.setKeyProvider = setKeyProvider;
/**
 * Gets structure tree for the category. If category is not specified (null), or its
 * filter is not found, returns the whole tree.
 * The root node of the tree always match RAML HL tree root.
 * @param categoryName
 */
function getStructure(categoryName) {
    return structureImpl.getStructure(categoryName);
}
exports.getStructure = getStructure;
/**
 * Gets structure tree for the category. If category is not specified (null), or its
 * filter is not found, returns the whole tree.
 * The root node of the tree always match RAML HL tree root.
 * @param categoryName
 */
function getStructureJSON(categoryName) {
    var structureRoot = structureImpl.getStructure(categoryName);
    if (!structureRoot)
        return null;
    return structureRoot.toJSON();
}
exports.getStructureJSON = getStructureJSON;
/**
 * Returns a map from category name to a category structure subtree.
 * @returns {{}}
 */
function getStructureForAllCategories() {
    return structureImpl.getStructureForAllCategories();
}
exports.getStructureForAllCategories = getStructureForAllCategories;
/**
 * Adds another decoration to the default decorator, allowing simple set up
 * of decorations as a map from node type to its icon and text style.
 * @param nodeType
 * @param decoration
 */
function addDecoration(nodeType, decoration) {
    structureDefault.addDecoration(nodeType, decoration);
}
exports.addDecoration = addDecoration;
/**
 * Chesk if instance is of TypedStructureNode type.
 * @param node
 */
function isTypedStructureNode(node) {
    return structureDefaultInterfaces.isTypedStructureNode(node);
}
exports.isTypedStructureNode = isTypedStructureNode;
/**
 * Gets details for a position.
 * Requires AST provider to be set up via setASTProvider method call.
 *
 * In case of the optional position parameter missing, AST provider's getSelectedNode method
 * will be called to determine the node to return detaisl for.
 * @param position - position index in text counting from 0. Optional.
 */
function getDetails(position) {
    return detailsImplementation.buildItemByPosition(position);
}
exports.getDetails = getDetails;
/**
 * Gets details JSON for a position.
 * Requires AST provider to be set up via setASTProvider method call.
 *
 * In case of the optional position parameter missing, AST provider's getSelectedNode method
 * will be called to determine the node to return detaisl for.
 * @param position
 */
function getDetailsJSON(position) {
    var detailsRoot = getDetails(position);
    if (!detailsRoot)
        return null;
    return detailsRoot.toJSON();
}
exports.getDetailsJSON = getDetailsJSON;
/**
 * Sets editor provider. This method MUST be called at least once, otherwise
 * it will be impossible to calculate the state and an empty state will be returned.
 * @param editorProvider
 */
function setEditorProvider(editorProvider) {
    tools.setEditorProvider(editorProvider);
}
exports.setEditorProvider = setEditorProvider;
//# sourceMappingURL=index.js.map